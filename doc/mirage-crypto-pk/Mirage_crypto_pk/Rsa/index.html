<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rsa (mirage-crypto-pk.Mirage_crypto_pk.Rsa)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">mirage-crypto-pk</a> &#x00BB; <a href="../index.html">Mirage_crypto_pk</a> &#x00BB; Rsa</nav><h1>Module <code>Mirage_crypto_pk.Rsa</code></h1><p><b>RSA</b> public-key cryptography algorithm.</p><nav class="toc"><ul><li><a href="#keys">Keys</a></li><li><a href="#the-rsa-transformation">The RSA transformation</a></li><li><a href="#key-generation">Key generation</a></li><li><a href="#pkcs#1-padded-modes">PKCS#1 padded modes</a></li><li><a href="#oaep-padded-modes">OAEP padded modes</a></li><li><a href="#pss-signing">PSS signing</a></li></ul></nav></header><section><header><h2 id="keys"><a href="#keys" class="anchor"></a>Keys</h2><p>Messages are checked not to exceed the key size, and this is signalled via the <a href="index.html#exception-Insufficient_key"><code>Insufficient_key</code></a> exception.</p><p>Private-key operations are optionally protected through RSA blinding.</p></header><dl><dt class="spec exception" id="exception-Insufficient_key"><a href="#exception-Insufficient_key" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Insufficient_key</span></code></dt><dd><p>Raised if the key is too small to transform the given message, i.e. if the numerical interpretation of the (potentially padded) message is not smaller than the modulus.</p></dd></dl><dl><dt class="spec type" id="type-pub"><a href="#type-pub" class="anchor"></a><code><span class="keyword">type</span> pub</code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-pub.e" class="anchored"><td class="def field"><a href="#type-pub.e" class="anchor"></a><code>e : Z.t;</code></td><td class="doc"><p>Public exponent</p></td></tr><tr id="type-pub.n" class="anchored"><td class="def field"><a href="#type-pub.n" class="anchor"></a><code>n : Z.t;</code></td><td class="doc"><p>Modulus</p></td></tr></table><code>}</code></dt><dd><p>The public portion of the key.</p><p><em><code>Sexplib</code> convertible</em>.</p></dd></dl><dl><dt class="spec value" id="val-pub"><a href="#val-pub" class="anchor"></a><code><span class="keyword">val</span> pub : <span>e:Z.t</span> <span>&#45;&gt;</span> <span>n:Z.t</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-pub">pub</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>pub ~e ~n</code> validates the public key: <code>1 &lt; e &lt; n</code>, <code>n &gt; 0</code>, <code>is_odd n</code>, and <code>numbits n &gt;= 89</code> (a requirement for PKCS1 operations).</p></dd></dl><dl><dt class="spec type" id="type-priv"><a href="#type-priv" class="anchor"></a><code><span class="keyword">type</span> priv</code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-priv.e" class="anchored"><td class="def field"><a href="#type-priv.e" class="anchor"></a><code>e : Z.t;</code></td><td class="doc"><p>Public exponent</p></td></tr><tr id="type-priv.d" class="anchored"><td class="def field"><a href="#type-priv.d" class="anchor"></a><code>d : Z.t;</code></td><td class="doc"><p>Private exponent</p></td></tr><tr id="type-priv.n" class="anchored"><td class="def field"><a href="#type-priv.n" class="anchor"></a><code>n : Z.t;</code></td><td class="doc"><p>Modulus (<code>p q</code>)</p></td></tr><tr id="type-priv.p" class="anchored"><td class="def field"><a href="#type-priv.p" class="anchor"></a><code>p : Z.t;</code></td><td class="doc"><p>Prime factor <code>p</code></p></td></tr><tr id="type-priv.q" class="anchored"><td class="def field"><a href="#type-priv.q" class="anchor"></a><code>q : Z.t;</code></td><td class="doc"><p>Prime factor <code>q</code></p></td></tr><tr id="type-priv.dp" class="anchored"><td class="def field"><a href="#type-priv.dp" class="anchor"></a><code>dp : Z.t;</code></td><td class="doc"><p><code>d mod (p-1)</code></p></td></tr><tr id="type-priv.dq" class="anchored"><td class="def field"><a href="#type-priv.dq" class="anchor"></a><code>dq : Z.t;</code></td><td class="doc"><p><code>d mod (q-1)</code></p></td></tr><tr id="type-priv.q'" class="anchored"><td class="def field"><a href="#type-priv.q'" class="anchor"></a><code>q' : Z.t;</code></td><td class="doc"><p><code>q^(-1) mod p</code></p></td></tr></table><code>}</code></dt><dd><p>Full private key (two-factor version).</p><p><b>Note</b> The key layout assumes that <code>p &gt; q</code>, which affects the quantity <code>q'</code> (sometimes called <code>u</code>), and the computation of the private transform. Some systems assume otherwise. When using keys produced by a system that computes <code>u = p^(-1) mod q</code>, either exchange <code>p</code> with <code>q</code> and <code>dp</code> with <code>dq</code>, or re-generate the full private key using <a href="index.html#val-priv_of_primes"><span><code>priv_of_primes</code></span></a>.</p><p><em><code>Sexplib</code> convertible</em>.</p></dd></dl><dl><dt class="spec value" id="val-priv"><a href="#val-priv" class="anchor"></a><code><span class="keyword">val</span> priv : <span>e:Z.t</span> <span>&#45;&gt;</span> <span>d:Z.t</span> <span>&#45;&gt;</span> <span>n:Z.t</span> <span>&#45;&gt;</span> <span>p:Z.t</span> <span>&#45;&gt;</span> <span>q:Z.t</span> <span>&#45;&gt;</span> <span>dp:Z.t</span> <span>&#45;&gt;</span> <span>dq:Z.t</span> <span>&#45;&gt;</span> <span>q':Z.t</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-priv">priv</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>priv ~e ~d ~n ~p ~q ~dp ~dq ~q'</code> validates the private key: <code>e, n</code> must be a valid <a href="index.html#type-pub"><code>pub</code></a>, <code>p</code> and <code>q</code> valid prime numbers <code>&gt; 0</code>, <code>odd</code>, probabilistically prime, <code>p &lt;&gt; q</code>, <code>n = p * q</code>, <code>e</code> probabilistically prime and coprime to both <code>p</code> and <code>q</code>, <code>q' = q ^ -1 mod p</code>, <code>1 &lt; d &lt; n</code>, <code>dp = d mod (p - 1)</code>, <code>dq = d mod (q - 1)</code>, and <code>d = e ^ -1 mod (p - 1) (q - 1)</code>.</p></dd></dl><dl><dt class="spec value" id="val-pub_bits"><a href="#val-pub_bits" class="anchor"></a><code><span class="keyword">val</span> pub_bits : <a href="index.html#type-pub">pub</a> <span>&#45;&gt;</span> <a href="../index.html#type-bits">bits</a></code></dt><dd><p>Bit-size of a public key.</p></dd></dl><dl><dt class="spec value" id="val-priv_bits"><a href="#val-priv_bits" class="anchor"></a><code><span class="keyword">val</span> priv_bits : <a href="index.html#type-priv">priv</a> <span>&#45;&gt;</span> <a href="../index.html#type-bits">bits</a></code></dt><dd><p>Bit-size of a private key.</p></dd></dl><dl><dt class="spec value" id="val-priv_of_primes"><a href="#val-priv_of_primes" class="anchor"></a><code><span class="keyword">val</span> priv_of_primes : <span>e:Z.t</span> <span>&#45;&gt;</span> <span>p:Z.t</span> <span>&#45;&gt;</span> <span>q:Z.t</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-priv">priv</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>priv_of_primes ~e ~p ~q</code> is the <a href="index.html#type-priv"><span>private key</span></a> derived from the minimal description <code>(e, p, q)</code>.</p></dd></dl><dl><dt class="spec value" id="val-priv_of_exp"><a href="#val-priv_of_exp" class="anchor"></a><code><span class="keyword">val</span> priv_of_exp : <span>?&#8288;g:<a href="../../../mirage-crypto-rng/Mirage_crypto_rng/index.html#type-g">Mirage_crypto_rng.g</a></span> <span>&#45;&gt;</span> <span>?&#8288;attempts:int</span> <span>&#45;&gt;</span> <span>e:Z.t</span> <span>&#45;&gt;</span> <span>d:Z.t</span> <span>&#45;&gt;</span> <span>n:Z.t</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-priv">priv</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>priv_of_exp ?g ?attempts ~e ~d n</code> is the unique <a href="index.html#type-priv"><span>private key</span></a> characterized by the public (<code>e</code>) and private (<code>d</code>) exponents, and modulus <code>n</code>. This operation uses a probabilistic process that can fail to recover the key.</p><p><code>~attempts</code> is the number of trials. For triplets that form an RSA key, the probability of failure is at most <code>2^(-attempts)</code>. <code>attempts</code> defaults to an unspecified number that yields a very high probability of recovering valid keys.</p><p>Note that no time masking is done for the computations in this function.</p></dd></dl><dl><dt class="spec value" id="val-pub_of_priv"><a href="#val-pub_of_priv" class="anchor"></a><code><span class="keyword">val</span> pub_of_priv : <a href="index.html#type-priv">priv</a> <span>&#45;&gt;</span> <a href="index.html#type-pub">pub</a></code></dt><dd><p>Extract the public component from a private key.</p></dd></dl></section><section><header><h2 id="the-rsa-transformation"><a href="#the-rsa-transformation" class="anchor"></a>The RSA transformation</h2></header><dl><dt class="spec type" id="type-or_digest"><a href="#type-or_digest" class="anchor"></a><code><span class="keyword">type</span> <span>'a or_digest</span></code> = <code>[ </code><table class="variant"><tr id="type-or_digest.Message" class="anchored"><td class="def constructor"><a href="#type-or_digest.Message" class="anchor"></a><code>| </code><code>`Message <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-or_digest.Digest" class="anchored"><td class="def constructor"><a href="#type-or_digest.Digest" class="anchor"></a><code>| </code><code>`Digest <span class="keyword">of</span> <a href="../../../mirage-crypto/Mirage_crypto/Hash/index.html#type-digest">Mirage_crypto.Hash.digest</a></code></td></tr></table><code> ]</code></dt><dd><p>Either an <code>'a</code> or its digest, according to some hash algorithm.</p></dd></dl><dl><dt class="spec type" id="type-mask"><a href="#type-mask" class="anchor"></a><code><span class="keyword">type</span> mask</code> = <code>[ </code><table class="variant"><tr id="type-mask.No" class="anchored"><td class="def constructor"><a href="#type-mask.No" class="anchor"></a><code>| </code><code>`No</code></td></tr><tr id="type-mask.Yes" class="anchored"><td class="def constructor"><a href="#type-mask.Yes" class="anchor"></a><code>| </code><code>`Yes</code></td></tr><tr id="type-mask.Yes_with" class="anchored"><td class="def constructor"><a href="#type-mask.Yes_with" class="anchor"></a><code>| </code><code>`Yes_with <span class="keyword">of</span> <a href="../../../mirage-crypto-rng/Mirage_crypto_rng/index.html#type-g">Mirage_crypto_rng.g</a></code></td></tr></table><code> ]</code></dt><dd><p>Masking (cryptographic blinding) mode for the RSA transform with the private key. Masking does not change the result, but it does change the timing profile of the operation.</p><ul><li><code>`No</code> disables masking. It is slightly faster but it <b>exposes the private key to timing-based attacks</b>.</li><li><code>`Yes</code> uses random masking with the global RNG instance. This is the sane option.</li><li><code>`Yes_with g</code> uses random masking with the generator <code>g</code>.</li></ul></dd></dl><dl><dt class="spec value" id="val-encrypt"><a href="#val-encrypt" class="anchor"></a><code><span class="keyword">val</span> encrypt : <span>key:<a href="index.html#type-pub">pub</a></span> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> Cstruct.t</code></dt><dd><p><code>encrypt key message</code> is the encrypted <code>message</code>.</p><dl><dt>raises Insufficient_key</dt><dd><p>(see <a href="index.html#exception-Insufficient_key"><span>Insufficient_key</span></a>)</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>message</code> is <code>0x00</code> or <code>0x01</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-decrypt"><a href="#val-decrypt" class="anchor"></a><code><span class="keyword">val</span> decrypt : <span>?&#8288;crt_hardening:bool</span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="index.html#type-mask">mask</a></span> <span>&#45;&gt;</span> <span>key:<a href="index.html#type-priv">priv</a></span> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> Cstruct.t</code></dt><dd><p><code>decrypt ~crt_hardening ~mask key ciphertext</code> is the decrypted <code>ciphertext</code>, left-padded with <code>0x00</code> up to <code>key</code> size.</p><p><code>~crt_hardening</code> defaults to <code>false</code>. If <code>true</code> verifies that the result is correct. This is to counter Chinese remainder theorem attacks to factorize primes. If the computed signature is incorrect, it is again computed in the classical way (c ^ d mod n) without the Chinese remainder theorem optimization. The deterministic <a href="PKCS1/index.html#val-sign"><span>PKCS1 signing</span></a>, which is at danger, uses <code>true</code> as default.</p><p><code>~mask</code> defaults to <code>`Yes</code>.</p><dl><dt>raises Insufficient_key</dt><dd><p>(see <a href="index.html#exception-Insufficient_key"><span>Insufficient_key</span></a>)</p></dd></dl></dd></dl></section><section><header><h2 id="key-generation"><a href="#key-generation" class="anchor"></a>Key generation</h2></header><dl><dt class="spec value" id="val-generate"><a href="#val-generate" class="anchor"></a><code><span class="keyword">val</span> generate : <span>?&#8288;g:<a href="../../../mirage-crypto-rng/Mirage_crypto_rng/index.html#type-g">Mirage_crypto_rng.g</a></span> <span>&#45;&gt;</span> <span>?&#8288;e:Z.t</span> <span>&#45;&gt;</span> <span>bits:<a href="../index.html#type-bits">bits</a></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-priv">priv</a></code></dt><dd><p><code>generate ~g ~e ~bits ()</code> is a new <a href="index.html#type-priv"><span>private key</span></a>. The new key is guaranteed to be well formed, see <a href="index.html#type-priv"><code>priv</code></a>.</p><p><code>e</code> defaults to <code>2^16+1</code>.</p><p><b>Note</b> This process might diverge if there are no keys for the given bit size. This can happen when <code>bits</code> is extremely small.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>e</code> is not a prime number (checked probabilistically) or not in the range <code>1 &lt; e &lt; 2^bits</code>, or if <code>bits &lt; 89</code> (as above, required for PKCS1 operations).</p></dd></dl></dd></dl></section><section><header><h2 id="pkcs#1-padded-modes"><a href="#pkcs#1-padded-modes" class="anchor"></a>PKCS#1 padded modes</h2></header><dl><dt class="spec module" id="module-PKCS1"><a href="#module-PKCS1" class="anchor"></a><code><span class="keyword">module</span> <a href="PKCS1/index.html">PKCS1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><b>PKCS v1.5</b> operations, as defined by <b>PKCS #1 v1.5</b>.</p></dd></dl></section><section><header><h2 id="oaep-padded-modes"><a href="#oaep-padded-modes" class="anchor"></a>OAEP padded modes</h2></header><dl><dt class="spec module" id="module-OAEP"><a href="#module-OAEP" class="anchor"></a><code><span class="keyword">module</span> <a href="OAEP/index.html">OAEP</a> : <span class="keyword">functor</span> (<a href="OAEP/argument-1-H/index.html">H</a> : <a href="../../../mirage-crypto/Mirage_crypto/Hash/index.html#module-type-S">Mirage_crypto.Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><b>OAEP</b>-padded encryption, as defined by <b>PKCS #1 v2.1</b>.</p></dd></dl></section><section><header><h2 id="pss-signing"><a href="#pss-signing" class="anchor"></a>PSS signing</h2></header><dl><dt class="spec module" id="module-PSS"><a href="#module-PSS" class="anchor"></a><code><span class="keyword">module</span> <a href="PSS/index.html">PSS</a> : <span class="keyword">functor</span> (<a href="PSS/argument-1-H/index.html">H</a> : <a href="../../../mirage-crypto/Mirage_crypto/Hash/index.html#module-type-S">Mirage_crypto.Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><b>PSS</b>-based signing, as defined by <b>PKCS #1 v2.1</b>.</p></dd></dl></section></div></body></html>