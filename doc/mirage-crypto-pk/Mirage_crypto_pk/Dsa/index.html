<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dsa (mirage-crypto-pk.Mirage_crypto_pk.Dsa)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">mirage-crypto-pk</a> &#x00BB; <a href="../index.html">Mirage_crypto_pk</a> &#x00BB; Dsa</nav><h1>Module <code>Mirage_crypto_pk.Dsa</code></h1><p><b>DSA</b> digital signature algorithm.</p><nav class="toc"><ul><li><a href="#dsa-signature-algorithm">DSA signature algorithm</a></li></ul></nav></header><section><header><h2 id="dsa-signature-algorithm"><a href="#dsa-signature-algorithm" class="anchor"></a>DSA signature algorithm</h2></header><dl><dt class="spec type" id="type-priv"><a href="#type-priv" class="anchor"></a><code><span class="keyword">type</span> priv</code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-priv.p" class="anchored"><td class="def field"><a href="#type-priv.p" class="anchor"></a><code>p : Z.t;</code></td><td class="doc"><p>Modulus</p></td></tr><tr id="type-priv.q" class="anchored"><td class="def field"><a href="#type-priv.q" class="anchor"></a><code>q : Z.t;</code></td><td class="doc"><p>Subgroup order</p></td></tr><tr id="type-priv.gg" class="anchored"><td class="def field"><a href="#type-priv.gg" class="anchor"></a><code>gg : Z.t;</code></td><td class="doc"><p>Group Generator</p></td></tr><tr id="type-priv.x" class="anchored"><td class="def field"><a href="#type-priv.x" class="anchor"></a><code>x : Z.t;</code></td><td class="doc"><p>Private key proper</p></td></tr><tr id="type-priv.y" class="anchored"><td class="def field"><a href="#type-priv.y" class="anchor"></a><code>y : Z.t;</code></td><td class="doc"><p>Public component</p></td></tr></table><code>}</code></dt><dd><p>Private key. <code>p</code>, <code>q</code> and <code>gg</code> comprise <i>domain parameters</i>.</p><p><em><code>Sexplib</code> convertible</em>.</p></dd></dl><dl><dt class="spec value" id="val-priv"><a href="#val-priv" class="anchor"></a><code><span class="keyword">val</span> priv : <span>?&#8288;fips:bool</span> <span>&#45;&gt;</span> <span>p:Z.t</span> <span>&#45;&gt;</span> <span>q:Z.t</span> <span>&#45;&gt;</span> <span>gg:Z.t</span> <span>&#45;&gt;</span> <span>x:Z.t</span> <span>&#45;&gt;</span> <span>y:Z.t</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-priv">priv</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>priv ~fips ~p ~q ~gg ~x ~y ()</code> constructs a private DSA key from the given numbers. Will result in an error if parameters are ill-formed: same as <a href="index.html#type-pub"><code>pub</code></a>, and additionally <code>0 &lt; x &lt; q</code> and <code>y = g ^ x mod p</code>. Note that no time masking is done on the modular exponentiation.</p></dd></dl><dl><dt class="spec type" id="type-pub"><a href="#type-pub" class="anchor"></a><code><span class="keyword">type</span> pub</code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-pub.p" class="anchored"><td class="def field"><a href="#type-pub.p" class="anchor"></a><code>p : Z.t;</code></td></tr><tr id="type-pub.q" class="anchored"><td class="def field"><a href="#type-pub.q" class="anchor"></a><code>q : Z.t;</code></td></tr><tr id="type-pub.gg" class="anchored"><td class="def field"><a href="#type-pub.gg" class="anchor"></a><code>gg : Z.t;</code></td></tr><tr id="type-pub.y" class="anchored"><td class="def field"><a href="#type-pub.y" class="anchor"></a><code>y : Z.t;</code></td></tr></table><code>}</code></dt><dd><p>Public key, a subset of <a href="index.html#type-priv"><span>private key</span></a>.</p><p><em><code>Sexplib</code> convertible</em>.</p></dd></dl><dl><dt class="spec value" id="val-pub"><a href="#val-pub" class="anchor"></a><code><span class="keyword">val</span> pub : <span>?&#8288;fips:bool</span> <span>&#45;&gt;</span> <span>p:Z.t</span> <span>&#45;&gt;</span> <span>q:Z.t</span> <span>&#45;&gt;</span> <span>gg:Z.t</span> <span>&#45;&gt;</span> <span>y:Z.t</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-pub">pub</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>pub ~fips ~p ~q ~gg ~y ()</code> constructs a public DSA key from the given numbers. Will result in an error if the parameters are not well-formed: <code>one &lt; gg &lt; p</code>, <code>q</code> probabilistically a prime, <code>p</code> probabilistically prime and odd, <code>0 &lt; y &lt; p</code>, <code>q &lt; p</code>, and <code>p - 1 mod q = 0</code>. If <code>fips</code> is specified and <code>true</code> (defaults to <code>false</code>), only FIPS-specified bit length for <code>p</code> and <code>q</code> are accepted.</p></dd></dl><dl><dt class="spec type" id="type-keysize"><a href="#type-keysize" class="anchor"></a><code><span class="keyword">type</span> keysize</code> = <code>[ </code><table class="variant"><tr id="type-keysize.Fips1024" class="anchored"><td class="def constructor"><a href="#type-keysize.Fips1024" class="anchor"></a><code>| </code><code>`Fips1024</code></td></tr><tr id="type-keysize.Fips2048" class="anchored"><td class="def constructor"><a href="#type-keysize.Fips2048" class="anchor"></a><code>| </code><code>`Fips2048</code></td></tr><tr id="type-keysize.Fips3072" class="anchored"><td class="def constructor"><a href="#type-keysize.Fips3072" class="anchor"></a><code>| </code><code>`Fips3072</code></td></tr><tr id="type-keysize.Exactly" class="anchored"><td class="def constructor"><a href="#type-keysize.Exactly" class="anchor"></a><code>| </code><code>`Exactly <span class="keyword">of</span> <a href="../index.html#type-bits">bits</a> * <a href="../index.html#type-bits">bits</a></code></td></tr></table><code> ]</code></dt><dd><p>Key size request. Three <em>Fips</em> variants refer to FIPS-standardized L-values (<code>p</code> size) and imply the corresponding N (<code>q</code> size); The last variants specifies L and N directly.</p></dd></dl><dl><dt class="spec type" id="type-mask"><a href="#type-mask" class="anchor"></a><code><span class="keyword">type</span> mask</code> = <code>[ </code><table class="variant"><tr id="type-mask.No" class="anchored"><td class="def constructor"><a href="#type-mask.No" class="anchor"></a><code>| </code><code>`No</code></td></tr><tr id="type-mask.Yes" class="anchored"><td class="def constructor"><a href="#type-mask.Yes" class="anchor"></a><code>| </code><code>`Yes</code></td></tr><tr id="type-mask.Yes_with" class="anchored"><td class="def constructor"><a href="#type-mask.Yes_with" class="anchor"></a><code>| </code><code>`Yes_with <span class="keyword">of</span> <a href="../../../mirage-crypto-rng/Mirage_crypto_rng/index.html#type-g">Mirage_crypto_rng.g</a></code></td></tr></table><code> ]</code></dt><dd><p>Masking (cryptographic blinding) option.</p></dd></dl><dl><dt class="spec value" id="val-pub_of_priv"><a href="#val-pub_of_priv" class="anchor"></a><code><span class="keyword">val</span> pub_of_priv : <a href="index.html#type-priv">priv</a> <span>&#45;&gt;</span> <a href="index.html#type-pub">pub</a></code></dt><dd><p>Extract the public component from a private key.</p></dd></dl><dl><dt class="spec value" id="val-generate"><a href="#val-generate" class="anchor"></a><code><span class="keyword">val</span> generate : <span>?&#8288;g:<a href="../../../mirage-crypto-rng/Mirage_crypto_rng/index.html#type-g">Mirage_crypto_rng.g</a></span> <span>&#45;&gt;</span> <a href="index.html#type-keysize">keysize</a> <span>&#45;&gt;</span> <a href="index.html#type-priv">priv</a></code></dt><dd><p><code>generate g size</code> is a fresh <a href="index.html#type-priv"><span>private</span></a> key. The domain parameters are derived using a modified FIPS.186-4 probabilistic process, but the derivation can not be validated. Note that no time masking is done for the modular exponentiations.</p><p><b>Note</b> The process might diverge if it is impossible to find parameters with the given bit sizes. This happens when <code>n</code> gets too big for <code>l</code>, if the <code>size</code> was given as <code>`Exactly (l, n)</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>size</code> is (`Exactly (l, n)), and either <code>l</code> or <code>n</code> is ridiculously small.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sign"><a href="#val-sign" class="anchor"></a><code><span class="keyword">val</span> sign : <span>?&#8288;mask:<a href="index.html#type-mask">mask</a></span> <span>&#45;&gt;</span> <span>?&#8288;k:Z.t</span> <span>&#45;&gt;</span> <span>key:<a href="index.html#type-priv">priv</a></span> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> Cstruct.t * Cstruct.t</code></dt><dd><p><code>sign ~mask ~k ~key digest</code> is the signature, a pair of <span class="xref-unresolved" title="unresolved reference to &quot;Cstruct.t&quot;"><code>Cstruct</code>.t</span>s representing <code>r</code> and <code>s</code> in big-endian.</p><p><code>digest</code> is the full digest of the actual message.</p><p><code>k</code>, the random component, can either be provided, or is deterministically derived as per RFC6979, using SHA256.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>k</code> is unsuitable (leading to r or s being 0).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-verify"><a href="#val-verify" class="anchor"></a><code><span class="keyword">val</span> verify : <span>key:<a href="index.html#type-pub">pub</a></span> <span>&#45;&gt;</span> <span>(Cstruct.t * Cstruct.t)</span> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> bool</code></dt><dd><p><code>verify ~key (r, s) digest</code> verifies that the pair <code>(r, s)</code> is the signature of <code>digest</code>, the message digest, under the private counterpart to <code>key</code>.</p></dd></dl><dl><dt class="spec value" id="val-massage"><a href="#val-massage" class="anchor"></a><code><span class="keyword">val</span> massage : <span>key:<a href="index.html#type-pub">pub</a></span> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> Cstruct.t</code></dt><dd><p><code>massage key digest</code> is the numeric value of <code>digest</code> taken modulo <code>q</code> and represented in the leftmost <code>bits(q)</code> bits of the result.</p><p>Both FIPS.186-4 and RFC6979 specify that only the leftmost <code>bits(q)</code> bits of <code>digest</code> are to be taken into account, but some implementations consider the entire <code>digest</code>. In cases where <a href="index.html#val-sign"><span>sign</span></a> and <a href="index.html#val-verify"><span>verify</span></a> seem incompatible with a given implementation (esp. if <a href="index.html#val-sign"><span>sign</span></a> produces signatures with the <code>s</code> component different from the other implementation's), it might help to pre-process <code>digest</code> using this function (e.g. <code>sign ~key (massage ~key:(pub_of_priv key) digest)</code>).</p></dd></dl><dl><dt class="spec module" id="module-K_gen"><a href="#module-K_gen" class="anchor"></a><code><span class="keyword">module</span> <a href="K_gen/index.html">K_gen</a> : <span class="keyword">functor</span> (<a href="K_gen/argument-1-H/index.html">H</a> : <a href="../../../mirage-crypto/Mirage_crypto/Hash/index.html#module-type-S">Mirage_crypto.Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>K_gen</code> can be instantiated over a hashing module to obtain an RFC6979 compliant <code>k</code>-generator for that hash.</p></dd></dl></section></div></body></html>